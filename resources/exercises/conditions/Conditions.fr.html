
<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->
<h2>Instructions conditionnelles</h2>

Les programmes faits d'une simple suite d'instructions comme celui de
l'exercice précédent sont bien ennuyeux. Ils font toujours la même chose, et
ne peuvent pas réagir aux conditions extérieurs. Une <b>instruction
conditionnelle</b> permet au programme de s'adapter en disant quelque chose
comme <i>S'il pleut, prend un parapluie</i>. 

<p>La syntaxe en [!thelang] est la suivante :</p>

<pre><code class="code-container">[!java|scala|c]if (<b>condition</b>) {
&nbsp;&nbsp;&nbsp;&nbsp;<b>aFaireSiVraie();</b>
&nbsp;&nbsp;&nbsp;&nbsp;<b>aFaireEnsuiteSiVraie();</b>
}[/!][!python]if <b>condition</b>:
&nbsp;&nbsp;&nbsp;&nbsp;<b>aFaireSiVraie()</b>
&nbsp;&nbsp;&nbsp;&nbsp;<b>aFaireEnsuiteSiVraie()</b>[/!]
<b>aFaireDansTousLesCas()[!java|c];[/!]</b></code></pre>

<p>Le mot <code>if</code> signifie «si» en anglais. Si la condition est vraie,
alors le code du bloc suivant sera exécuté, puis l'exécution se poursuivra
avec la suite du code, après le bloc. Sinon, si la condition est fausse, le
bloc suivant sera ignoré et l'exécution passera directement au code placé
après lui. Le bloc conditionnel peut contenir plusieurs instructions. Il
peut même contenir d'autre tests, avec leurs sous-blocs associés.</p>

<p>Dans cet exemple, les instructions <code>aFaireSiVraie()</code> et
<code>aFaireEnsuiteSiVraie()</code> seront exécutée si (et seulement si) la
condition est vraie tandis que l'instruction
<code>aFaireDansTousLesCas()</code> sera exécutée que la condition soit
vraie ou fausse. 
</p>

<p>En [!thelang], les blocs sont
[!java|scala|c]délimités par des accolades : le symbole { commence un bloc
tandis
que le symbole } le ferme.  Les caractères blancs ne sont pas pris en
compte[/!][!java|c].[/!][!scala], tant que les instructions restent séparées
soit par des points-virgules, soit par des retour à la ligne.[/!]
[!java|scala|c]Il reste très important d'indenter correctement votre code
pour qu'il reste lisible.[/!]
[!python]marqués par l'indentation : toutes les lignes indentés (=décalées
vers la droite par des espaces) font partie du bloc. Il est assez courant
d'utiliser quatre espaces pour indenter le code, mais cela fonctionne quel
que soit le nombre de caractères blancs utilisés pour cela. Simplement,
toutes les lignes d'un bloc donné doivent utiliser le même nombre de
blancs. La fin des blocs de code n'est pas marquée par un symbole
particulier: il s'arrête dès que les lignes ne sont plus
indentées. N'oubliez pas les deux points (:) à la fin de la ligne
<code>if</code>, python en a besoin pour savoir qu'un nouveau bloc commence.
Le fait que python utilise l'indentation pour maquer les blocs est un
avantage pour les débutants: cela vous forcera à respecter des critères
stricts de mise en forme de votre code.[/!]
Il est très facile de se perdre dans un code qui n'est pas correctement
indenté. Il est donc important que vous fassiez en sorte que votre code
reste clair et lisible pour que le relire et le modifier reste plaisant et
productif.</p>

[!python]
<p>Toutes les instructions d'un bloc doivent avoir la même indentation, et il
n'est pas possible de couper un bloc. Les deux exemples suivants de code
sont incorrects et vont générer des erreurs.</p>
<pre><code class="code-container">if <b>condition</b>:
&nbsp;&nbsp;&nbsp;&nbsp;<b>quoiFaire()</b>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>quoiFaireEnsuite()</b> <span class="comment"># une espace de trop</span>
<b>quoiFaireDansTousLesCas()</b>
</code></pre>
<pre><code class="code-container">if <b>condition</b>:
&nbsp;&nbsp;&nbsp;&nbsp;<b>quoiFaire()</b>
<b>quoiFaireDansTousLesCas()</b>
&nbsp;&nbsp;&nbsp;&nbsp;<b>quoiFaireEnsuite()</b> <span class="comment"># Ce bloc n'est rattaché à aucune ligne de condition</span>
</code></pre>
[/!]
<p>La condition doit être une expression de type
<code>[!c]int[/!][!java]boolean[/!][!scala|python]Boolean[/!]</code>
(expression booléenne).  Le sous-bloc sera exécuté seulement si cette
expression vaut <code>[!c]1[/!][!java|scala]true[/!][!python]True[/!]</code>
(vrai), et il sera ignoré si sa valeur est
<code>[!c]0[/!][!java|scala]false[/!][!python]False[/!]</code> (faux).
<code>[!java|scala]true[/!][!python]True[/!]</code> et
<code>[!java|scala]false[/!][!python]False[/!]</code> sont des constantes
définies directement par [!thelang], tout comme 0 ou 1 en mathématiques.</p>

<p>La condition peut aussi être une variable booléenne (nous reviendrons sur
les variables dans un autre exercice, pas de panique) ou un test
arithmétique,comme <code>x == 5</code>, qui teste si la valeur actuelle de
<tt>x</tt> est 5, ou bien comme <b>!=</b> (teste l'inégalité, càd si le
membre gauche a une valeur différente du membre droit), <b>&lt;</b>
(inférieur à), <b>&gt;</b> (supérieur à), <b>&lt;=</b> (inférieur ou égal
à), <b>&gt;=</b> (supérieur ou égal à).</p>

<p>Attention au piège classique, qui consiste à tester l'égalité d'une variable
avec = au lieu de ==. Heureusement, [!java|scala|c]le
compilateur[/!][!python]l'interpréteur[/!] détecte le plus souvent ce
problème et vous le signale, mais pas tout le temps. Si la variable est de
type booléen, il peut se faire prendre au piège, et il convient donc d'être
attentif...</p>

<p>La condition peut également être un appel à certaines méthodes
particulières, dont le résultat est un booléen. Par exemple, la méthode
<tt>estFaceMur()</tt> de la buggle renvoie
[!c]1[/!][!java|python|scala]vrai[/!] si la buggle est face à un mur, et
[!c]0[/!][!java|python|scala]faux[/!] sinon.</p>

<p>Enfin, il est possible de construire une condition composée de plusieurs
sous-conditions reliées par des opérations booléennes:</p>
<ul>
  <li><code>cond1 [!java|scala|c]&&[/!][!python]and[/!] cond2</code> est vraie si
<tt>cond1</tt> <b>et</b> <tt>cond2</tt> est vraie (d'ailleurs, si
<tt>cond1</tt> est fausse, <tt>cond2</tt> n'est même pas évaluée puisqu'on
sait déjà que la conjonction des deux propositions ne peut pas être vraie).</li> 
  <li><code>cond1 [!java|scala|c]||[/!][!python]or[/!] cond2</code> est vraie si
<tt>cond1</tt> <b>ou</b> <tt>cond2</tt> est vraie (d'ailleurs, si
<tt>cond1</tt> est vraie, <tt>cond2</tt> n'est même pas évaluée puisqu'on
sait déjà que la disjonction des deux propositions ne peut pas être fausse).</li>
  <li><code>[!java|scala|c]![/!][!python]not [/!]cond</code> est vraie si
<tt>cond</tt> ne l'est pas.</li>
  <li>Quand les expressions deviennent compliquées, il est préférable d'ajouter
quelques parenthèses pour lever toute ambiguïté sur l'ordre
d'évaluation. N'hésitez pas à mettre suffisamment de parenthèses pour la
rendre plus lisible.</li>
</ul> 

<p>Pour finir, il est possible de spécifier ce qu'il faut faire quand la
condition est fausse, en utilisant la syntaxe suivante («else» signifie
«sinon» en anglais). Dans ce cas, l'instruction
<code>aFaireSiLaConditionEstFausse()</code> ne sera exécutée que si la
condition est fausse.</p>
 <pre><code class="code-container">[!java|scala|c]if (<b>condition</b>) {
&nbsp;&nbsp;&nbsp;&nbsp;<b>aFaireSiLaConditionEstVraie();</b>
} else {
&nbsp;&nbsp;&nbsp;&nbsp;<b>aFaireSiElleEstFausse();</b>
}[/!][!python]if (<b>condition</b>):
&nbsp;&nbsp;&nbsp;&nbsp;<b>aFaireSiLaConditionEstVraie()</b>
else:
&nbsp;&nbsp;&nbsp;&nbsp;<b>aFaireSiElleEstFausse()</b>[/!]</code></pre>
[!python]
<p>N'oubliez pas les deux points (:) après le else, ils indiquent qu'un nouveau
bloc débute.</p>
[/!]
<h3>Objectif de cet exercice</h3><a name="Objectifs"/> Si la buggle est face à un mur, il faut reculer d'un
pas; Sinon, il faut avancer d'un pas.
Pour savoir si on est face à un mur, il suffit d'utiliser la méthode
prédéfinie des buggles nommée <code>estFaceMur()</code>. 

<p>Cet exercice est un peu particulier : il faut que votre programme fonctionne
pour plusieurs buggles, chacune étant dans une situation initiale
différente. Le même code sera utilisé pour chacune d'entre elles.</p>

<p>Quand votre programme fonctionne enfin, passez à l'exercice suivant.</p>

<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->
<h2>Methods with parameters</h2>

<p>Don't you get tired of writing again and again the code to move by a fixed
amount of steps? On the other hand, writing <tt>forward2()</tt>,
<tt>forward3()</tt>, <tt>forward4()</tt>, as well as <tt>backward2()</tt>,
<tt>backward3()</tt>, <tt>backward4()</tt>, and so on does not really help, 
to say the less.</p>

<p>Luckily, it is possible to pass <b>parameters</b> to your methods. You have
to specify their type and name between the parenthesis after the method
name. Then, you can use them in the method body as if it were variables
defined in there, and which initial value is what the caller specified.</p>

<pre>[!java|c]double [/!]divideByTwo([!java|c]double [/!]x[!scala]: Double[/!])[!scala]: Double =[/!] [!java|scala|c]{[/!][!python]:[/!]
     return x / 2[!java|c];[/!]
[!scala|java|c]}[/!]</pre>

<p>As caller, you have to specify the initial value of this "variables" between
the call's parenthesis.</p>
<pre>[!java|c]double [/!][!scala]val [/!]result = divideByTwo(3.14)[!java|c];[/!]</pre>

<p>If you want several parameters, you need to separate them with comas (,)
both in the declaration and calls.</p>

<pre>[!java|c]double divide(double x, double y) {[/!]
[!scala]def divide(x:Double, y:Double): Double = {[/!]
[!python]def divide(x, y):[/!]
     return x / y[!java|c];[/!]
[!java|scala|c]}[/!]</pre>
<pre>[!java|c]double res = divide(3.14 , 1.5);[/!]
[!scala]val res = divide(3.14 , 1.5)[/!]
[!python]res = divide(3.14 , 1.5)[/!]</pre>

[!java|scala]
<p>In [!thelang], you can declare several methods of the same name as long as
they don't have the same <b>signature</b>, that is, the same amount of 
parameters and the same parameters' types.</p>

<pre>[!java]double max(double x, double y)[/!][!scala]def max(x:Double, y:Double): Double =[/!] {
  if (x > y) {
    return x;
  }
  return y;
}[!java]int max(int x, int y)[/!][!scala]def max(x:Int, y:Int): Int =[/!] {
  if (x > y) {
    return x;
  }
  return y;
}
[!java]int max(int x, int y; int z)[/!][!scala]def max(x:Int, y:Int, z:Int): Int =[/!] {
  if (x > y && x > z) {
    return x;
  }
  if (y > z) {
    return y;
  }
  return z;
}</pre>

<p>Observe that we omitted the <tt>else</tt> branches of each <tt>if</tt>. It
works anyway because a <tt>return</tt> interrupts the method execution. If
we arrive to the last line of <code>[!java]max(int,int)[/!][!scala]max(Int,Int):Int[/!]</code>,
we know that <code>x&lt;=y</code> because otherwise, the <tt>return</tt> of line
2 would have stopped the execution.</p>
[/!]

<!-- introduce default value for parameters in Python language -->

<h3>Exercise goal</h3>
<p>This time, you have to write a <code>
[!java|c]move(int stepCount,[!java]boolean[/!][!c]int[/!] goForward)[/!]
[!scala]move(stepCount: Int,goForward: Boolean)[/!]
[!python]move(stepCount,goForward)[/!]
</code> method which moves forward by <code>stepCount</code> steps if
<code>goForward</code> is true, and moves back of that amount of steps if the
boolean is false.</p>

<p>This time, there is only one world but seven buggles, all sharing the same code.
This code should not be really problematic for you to write, actually.</p>

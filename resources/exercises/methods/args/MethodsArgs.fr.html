
<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->
<h2>Méthodes avec paramètres</h2>

<p>N'êtes vous pas fatigué d'écrire encore et encore le code qui permet
d'avancer ou de reculer d'un nombre prédéterminé de pas ? Oui, mais écrire
les méthode <tt>avance2()</tt>, <tt>avance3()</tt>, <tt>avance4()</tt>, et
<tt>recule2()</tt>, <tt>recule3()</tt>, <tt>recule4()</tt>, et ainsi de
suite, ça ne constitue pas un réel gain de temps. Et puis, c'est carrément
moche !</p>

<p>Luckily, it is possible to pass <b>parameters</b> to your methods. You have
to specify their [!java|scala|c]type and[/!] name between the parenthesis
after the method name. Then, you can use them in the method body as if it
were variables defined in there, and which initial value is what the caller
specified.</p>

<pre>[!java|c]double [/!]diviseParDeux([!java|c]double [/!]x[!scala]: Double[/!])[!scala]: Double =[/!] [!java|scala|c]{[/!][!python]:[/!]
     return x / 2[!java|c];[/!]
[!scala|java|c]}[/!]</pre>

<p>À l'usage, il faut indiquer les valeurs qu'elles doivent prendre entre les
parenthèses de l'appel.</p>
<pre>[!java|c]double [/!][!scala]val [/!]blah = divideByTwo(3.14)[!java|c];[/!]</pre>

<p>Si on veut avoir plusieurs paramètres, il faut les séparer par des virgules,
lors de la déclaration comme lors de l'appel.</p>

<pre>[!java|c]double divise(double x, double y) {[/!]
[!scala]def divise(x:Double, y:Double): Double = {[/!]
[!python]def divise(x, y):[/!]
     return x / y[!java|c];[/!]
[!java|scala|c]}[/!]</pre>
<pre>[!java|c]double res = divide(3.14 , 2);[/!]
[!scala]val res = divide(3.14 , 2)[/!]
[!python]res = divide(3.14 , 2)[/!]</pre>

[!java|scala]
<p>En [!thelang], il est possible d'avoir plusieurs méthodes du même nom, à
condition qu'elles n'aient pas la même <b>signature</b>, c'est à dire le
même nombre de paramètres et les mêmes types de paramètres.</p>

<pre>[!java]double max(double x, double y)[/!][!scala]def max(x:Double, y:Double): Double =[/!] {
  if (x > y) {
    return x;
  }
  return y;
}[!java]int max(int x, int y)[/!][!scala]def max(x:Int, y:Int): Int =[/!] {
  if (x > y) {
    return x;
  }
  return y;
}
[!java]int max(int x, int y; int z)[/!][!scala]def max(x:Int, y:Int, z:Int): Int =[/!] {
  if (x > y && x > z) {
    return x;
  }
  if (y > z) {
    return y;
  }
  return z;
}</pre>

<p>Remarquez que nous avons ici laissé de coté les <tt>else</tt> de chaque
alternative. Cela fonctionne tout de même car un <tt>return</tt> interrompt
l'exécution de la méthode. Si on arrive à la dernière ligne de
<code>[!java]max(int,int)[/!][!scala]max(Int,Int):Int[/!]</code>, on est
donc sûr que <code>x&lt;=y</code> car dans le cas contraire, le
<tt>return</tt> de la deuxième ligne aurait arrêté l'exécution de la
fonction.</p>
<!-- introduce default value for parameters in Python language -->
[/!]



<h3>Objectif de cet exercice</h3>
<p>This time, you have to write a <code> [!java|c]move(int
stepCount,[!java]boolean[/!][!c]int[/!] goForward)[/!]
[!scala]move(stepCount: Int,goForward: Boolean)[/!]
[!python]move(stepCount,goForward)[/!] </code> method which moves forward by
<code>stepCount</code> steps if <code>goForward</code> is true, and moves
back of that amount of steps if the boolean is false.</p>

<p>Cette fois, il y a un seul monde, et sept buggles, qui exécutent toutes le
code que vous allez écrire.
Cet exercice ne devrait pas vous poser de problème particulier.</p>

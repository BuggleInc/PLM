
<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->
<h2>Perdu dans les îles</h2>

<p>Vous pensiez que votre algorithme était suffisant pour échapper de tous les
labyrinthes ? Et bien, pas tous les labyrinthes...
</p>

<p>L'algorithme de suivi de mur que nous avons utilisé jusqu'à présent
fonctionne seulement si l'entrée et la sortie sont placées à côté de murs
connectés à un mur externe. Mais si la buggle commence au milieu du
labyrinthe, il peut exister des pans de mur déconnectés du mur externe.

<p>Dans cette situation, notre précédente stratégie ferait notre buggle tourner
en rond pour toujours sur l'un de ces îlots. En effet, le labyrinthe dont
vous devez vous échapper maintenant contient des îles, et la buggle ne
commence pas sur un des murs externes. Vous pouvez essayer si vous voulez :
Copie/collez votre code et appuyez sur le bouton 'Exécuter' pour admirez
votre solution précédente échouer lamentablement.</p>

<p>Cette méthode de suivre un mur est toujours efficace est permet d'échapper
de manière assez efficace à certaines parties du labyrinthe, on ne va donc
pas la supprimer entièrement. À la place, nous allons cesser de suivre le
mur sous certaines conditions. Notez que le baggle repose près d'un mur
externe du labyrinthe. Donc nous voulons atteindre un mur externe et ensuite
le suivre. Nous avons par exemple de rechercher le mur nord avant de le
suivre jusqu'au baggle.

<p>Pour trouver le mur nord, vous avez tout simplement à foncez vers le nord
tant que c'est possible, et quand vous faites face à un obstacle, vous
l'évitez (en utilisant la méthode précédente).</p>

<div class="tip" id="tip-1" alt="Je suis perdu, je voudrais plus d'indications">
	Notre nouvelle méthode run() va consister en deux états: notre buggle va
alterner entre le mode «coureur au nord» et le mode «suiveur à gauche». Vous
commencez dans le mode «coureur au nord», et vous passerez au mode «suiveur
à gauche» quand il y aura un mur au nord (n'oubliez pas de vous assurez
d'avoir un mur à votre gauche avant de changer de passer au mode «suiveur à
gauche»). Vous repasserez au mode «coureur au nord» dès que votre buggle
fera face au nord et qu'elle n'est pas face à un mur. La manière la plus
simple d'écrire une telle machine à état est quelque chose de ce type: 
<pre>[!scala]var etat=0;
etat match  {
  case 0 => // courir au nord
     ...
     etat = 1;
  case 1 => // suivre à gauche
     ...
     etat = 0;
  case _ => println("Ce cas ne devrait pas arriver. Corrigez ce problème svp.")
}[/!][!java|c]int etat=0;
switch (etat) {
  case 0: // courir au nord
     ...
     etat = 1;
     break;
  case 1: // suivre à gauche
     ...
     etat = 0;
     break;
}[/!][!python]coureurNord = True
if coureurNord:
     ...
     coureurNord = False
else: # suiveur à gauche
     ...
     coureurNord = True[/!]</pre>
     
[!scala]<br/>N'oubliez pas le cas par défaut (qui accepte _), ou scala vous donnera un
message d'erreur en échange de votre filtrage incomplet.
</div>
	
<p>N'oubliez pas de faire ramasser le baggle par votre buggle à la fin de votre
code.</p>
	
	
<p>Vous êtes prêts. Tout ceci devrait suffire pour vous permettre de trouver
comment sortir de ce labyrinthe, mais si ce n'est pas le cas, vous pouvez
toujours demander l'astuce. Mais vous n'avez plus besoin d'aide, n'est-ce
pas ?</p>

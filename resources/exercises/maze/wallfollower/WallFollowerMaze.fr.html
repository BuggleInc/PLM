
<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->
<h2>Longer les murs</h2>

<p>Cette fois-ci le labyrinthe est beaucoup plus compliqué. Le hasard ne sera
pas suffisant, il va falloir être intelligent !</p>

<p>Heureusement, ce labyrinthe est plus simple qu'il n'y paraît: tous les murs
sont connectés les uns aux autres. Pour sortir de ce genre de labyrinthe, il
suffit à votre buggle de longer un mur (celui à sa droite, ou celui à sa
gauche: c'est sans importance). Tout en gardant sa patte posée sur ce mur,
votre buggle doit avancer jusqu'à ce qu'elle trouve la sortie du labyrinthe
et ce biscuit qu'il apprécie tant.</p>

<p>Cet algorithme fonctionne ici car il n'y a pas d'île de murs isolés, ce qui
fait que la buggle ne peut pas boucler autour des murs sans rencontrer le
biscuit qu'elle cherche.</p>

<h3>Objectif de cet exercice</h3>L'objectif de cet exercice est d'écrire un algorithme permettant à votre
buggle de sortir du labyrinthe.

<p>Comme dit précédemment, le mur choisi n'a pas d'importance. Simplement, la
démo suit le mur gauche, et il serait donc avisé d'en faire de même pour
simplifier la comparaison de votre solution et de la démo.</p> 

<p>Écrivez une méthode <code>keepHandOnSideWall()</code> qui fait avancer votre
buggle d'une case tout en gardant la patte sur le mur du côté choisi. Vous
devez vous assurer que votre buggle garde toujours la patte sur le mur et
également qu'elle ne risque pas de percuter un mur. Vous pouvez regarder
l'indice (hint) si vous êtes coincé, mais vous devriez d'abord essayer de le
faire par vous-même.</p> 

<p>Enfin, écrivez l'algorithme complet qui parcourt le labyrinthe pas à pas
jusqu'à trouver le biscuit et la sortie. N'oubliez pas de prendre le baggle.</p>

<div class="tip" id="tip-1" alt="Je suis perdu, je voudrais plus d'indications">
<p>Quand votre buggle a un mur à sa gauche, il faut considérer trois situations
possibles, qui dépendent des murs alentours. Le tableau suivant représente
graphiquement chaque situation initiale, et où vous devez placer votre
buggle à la fin de l'étape.</p>
<table border=1>
<tr>
 <td></td>
 <td>Cas 1</td>
 <td>Cas 2</td>
 <td>Cas 3</td>
</tr><tr>
 <td>Situation initiale</td>
 <td><img src="exercises/maze/wallfollower/1A.png"/></td>
 <td><img src="exercises/maze/wallfollower/2A.png"/></td>
 <td><img src="exercises/maze/wallfollower/3A.png"/></td>
</tr><tr>
 <td>Étape suivante</td>
 <td><img src="exercises/maze/wallfollower/1B.png"/></td>
 <td><img src="exercises/maze/wallfollower/2B.png"/></td>
 <td><img src="exercises/maze/wallfollower/3B.png"/></td>
</tr>
</table>
<p>Si vous faites un <code>right()</code> dans tous les cas à la fin de votre
fonction, il est possible de l'écrire en trois lignes avec une boucle
<code>while</code>.</p>
</div>

    

<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->
<h2>Locate a Landing Zone</h2>

<p>After 200 days of traveling space and eating cereals you finally reach
Mars. Time to land at last!</p>

<p>The lander is on autopilot and all you have to do is look around and tell it
where to land. The lander must <b>land on a flat zone</b> if you want to remain
in one piece. You indicate the lander where to land by modifying the
<code>getLandingZone</code> function so that it returns a 
[!java|scala]<code>Segment</code> representing the zone of your choice.

<p>A segment is composed of two <code>Point</code>s, each of them composed of
two <code>double</code>s. A segment is built via the 
<code>Segment([!java]Point [/!]start[!scala]:Point[/!], [!java]Point [/!]end[!scala]:Point[/!])</code> constructor. 
A point is built via the <code>Point([!java]double [/!]x[!scala]:Double[/!], [!java]double [/!]y[!scala]:Double[/!])</code> constructor. A point's coordinates are accessible via its
<code>[!java]double [/!]x()[!scala]:Double[/!]</code> and
<code>[!java]double [/!]y()[!scala]:Double[/!]</code> methods.</p>[/!]

[!python]tuple of two X coordinates representing the zone of your choice.[/!]

<p>In order to determine which zone to return, you'll need to call
<code>[!java]List&lt;Point&gt; [/!]getGround()[!scala]List[Point][/!]</code>, which returns 
the vertices of the ground's profile as a list of 
[!java|scala]<code>Point</code>[/!] [!python]tuples (x,y)[/!].</p>

<p>One more thing: your function should return a valid flat zone in any kind of
situation, not just for the currently visualized one. That's because it will
be not only tested against that world, but also against the one we had in the
previous exercise. As usual, you can see the other existing worlds with the
appropriate combobox.</p>

<p>Have a safe landing! Don't forget to put on your space suit on your way
out.</p>

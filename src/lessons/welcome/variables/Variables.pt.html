
<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->
<h2>A armazenar e a manipular dados</h2>
  <p>Os programas que escrevemos até agora não tem um ponto fundamental da
computação. Na verdade, é sobre processar <b>dados</b> através de
<b>instruções</b> específicas. No mundo dos buggles, os dados principais
estão escondidos atrás de uma representação gráfica, mas isto não é motivo
para nunca manipular alguns dados explicitamente. </p>

  <h3>Dados em [!thelang]</h3>
<p>Num programa, pode usar vários <i>tipos</i> de dados, tais como números
inteiros ou cadeias de caracteres, ou caracteres. Se quiser usar um dado
várias vezes, precisa armazená-la numa <i>variável</i>, que é uma célula de
memória a conter um valor: põe o seu dado (digamos o valor '5') na variável
(digamos 'comprimento') e pode recuperá-la mais tarde quando precisar
dela. Isto é muito similar a uma caixa com o rótulo 'presente' na qual pode
pôr alguma coisa, como um perfume "Channel N°5".  </p>

<h3>Declaração de variáveis</h3>  

<p><b>Declarar</b> (ie, criar) uma variável em [!thelang], é muito
simples. Simplesmente escreve [!java]o tipo dele, um espaço e o nome da
variável.[/!] [!scala]a palavra-chave <code>var</code>, o nome da variável,
um dois-pontos (:) e o tipo da variável, um sinal de igualdade (=) e um
valor inicial.[/!] [!python]o nome da variável, um sinal de igual (=) e um
valor inicial.[/!] O nome da variável é o rótulo para recuperar ela
depois[!python].[/!] [!java|scala] enquanto o tipo é o tipo de dado que a
variável aceita guardar.[/!] É proibido usar espaços em nomes de
variáveis. Pode nomear uma variável <code>quantidadeDePassos</code> se
quiser, mas <code>quantidade de passos</code> não é um nome válidos.
  </p>

[!c|java]
  <p>Então, para criar uma variável chamada <b>x</b> para guardar inteiros, deve
escrever:</p> 
  <pre>int x;</pre>
  <p>Se quiser, pode especificar o valor inicial da variável a adicionar um
símbolo de igual (=) seguido do valor depois da declaração.</p>
  <pre>int x=5;</pre>
[/!] [!python]
  <p>Então se quiser que a variável tenha o valor inicial de 5, deve digitar: </p>
  <pre>x = 5</pre>
[/!] [!scala]
  <p>Logo, para criar uma variável chamada <b>x</b> que vai guardar inteiros e
com 42 como valor inicial, deve escrever:</p> 
  <pre>var x:Int = 42</pre>
  <p>Na maioria dos casos, o compilador é capaz de adivinhar o tipo da variável
baseado no valor inicial e pode omitir o tipo:</p>
  <pre>var x = 42</pre>
  <p>Ainda tem que especificar se usa alguns valores genéricos como uma
inicialização, tais como o valor muito especial <code>null</code>, cujo tipo
parece ser ambíguo. Mesmo quando o tipo é claro, ainda pode especificar o
tipo se preferir. Portanto, se quiser que a variável contenha 5 como valor
inicial, deve digitar: </p>
  <pre>var x: Int =  5 <span class="comment">// Posso definir o tipo se quiser</span>
var y =  10      <span class="comment">// ou posso omitir o tipo se preferir</span></pre>
[/!] [!java|scala|c]
<p>Como pode ver, as variáveis são <b>tipadas</b> em [!thelang], que significa
que elas são de certa forma especializadas: Uma dada variável pode armazenar
apenas dados de um tipo; nem pense em guardar números numa variável que é
feita para letras! Dizemos que a linguagem [!thelang] é <b>estaticamente
tipada</b>.</p>
<p>Outras linguages (como Python) são menos charas e permitem que guarde
qualquer tipo de dado em qualquer variável, sem restrições (estas linguagens
são ditas <b>dinamicamente tipadas</b>). Parecem mais fáceis à primeira
vista, mas este tipo de restrição permite que o compilador perceba mais
erros de lógica para você, o que é bom. Num certo sentido, Python é mais
fácil de escrever mas os erros surgem com mais frequencia do que em
[!thelang].</p>
<p>Aqui estão alguns dos tipos em [!thelang]:</p>
<ul>
  <li><b>[!java|c]int[/!][!scala]Int[/!]</b>, para inteiros;</li>
  <li><b>[!java|c]double[/!][!scala]Double[/!]</b>, para números com vírgula;</li> 
  <li><b>[!c]int[/!][!java]boolean[/!][!scala]Boolean[/!]</b>, para booleanos, que
são valores ou [!c]1[/!][!java|scala]true[/!] ou
[!c]0[/!][!java|scala]false[/!];</li>
  <li><b>[!c]char*[/!][!java|scala]String[/!]</b>, para cadeias de caracteres.</li>
</ul>
[/!] [!python]
<p>Como pode ver, as variáveis não são <b>digitadas</b> em Python, o que
significa que elas não são especializadas em nenhum tipo de dado.  Uma
determinada variável armazena qualquer tipo de dado de um determinado tipo:
pode armazenar um número numa variável e, mais tarde, armazenar um número na
mesma variável.  Os valores ainda são digitados, mas não a variável. Diz-se
que Python é de <b>tipagem dinâmica</b>.</p>
<p>Outras linguagens (como Java, Scala ou C), são muito mais exigentes e
impedem que misture tipos de dados numa certa variável (dizemos que elas são
<b>esticamente tipadas</b>). Isto parece inconveniente à primeira vista, mas
este tipo de restrição permite que o compilador capture mais erros de lógica
para você, o que também é bom. Num certo sentido, Python é mais fácil de
escrever mas erros podem surgir mais facilmente.</p>
[/!]
  

<p class="scala">Se sabe que o valor da sua "variável" nunca vai mudar (eg quando ela contém
o tamanho do ecrã ou outro valor constante), então deve fazer dela um
<b>valor</b> ao invés de uma variável. Simplesmente mude a palavra-chave
<code>var</code> para <code>val</code>. O compilador pode então verificar as
suas ações e capturar o seu erro quando inadvertidamente modificar o
valor. Mais interessante ainda, o compilador pode produzir código mais
rápido em alguns casos.</p>

<p>Variáveis funcionam muito parecido com cadeias, números com vírgula e
valores booleanos.</p>

<pre class="c">char* nome = "Martin Quinson";
double altura=1.77; <span class="comment">// em metros</span>
int casado=1;<span class="comment">// 1 significa "verdadeiro"; false é 0</span></pre>


<pre class="java">Cadeia nome = "Martin Quinson";
double altura=1.77; <span class="comment">// em metros</span>
boolean casado=true;<span class="comment">// o contrário se escreve "false"</span></pre>

<pre class="scala">val nome:String = "Martin Quinson"; <span class="comment">// isto não pode ser modificado (é um valor)</span>
var altura: Double = 1.77; <span class="comment">// em metros</span>
var casado = true; <span class="comment">// o contrário se escreve "false"</span>
<span class="comment">// Scala sabe que 'true' é um valor Booleano, não precisa repetir</span></pre>

<pre class="python">firstName = "Martin"
lastName = 'Quinson' <span class="comment"># aspas e aspas simples funcionam aqui</span>
frase = "uma gota d'água é sempre melhor que nada" <span class="comment"># uma aspas simples entre aspas duplas vale</span> 
altura=1.77 <span class="comment"># em metros</span>
casado=True <span class="comment"># o contrário se escreve "False"</span></pre>

<h3>Atribuições</h3>

<p>Uma vez que a sua variável está declarada, pode lhe <b>atribuir</b> um novo
valor mais tarde no programa. Isto é bem fácil:</p> 
<pre>x = 3[!java|c];[/!]</pre>

<p>À esquerda do símbolo de igual pode pôr uma expressão aritmética a conter
constantes, variáveis e operações.</p>

<pre>x = 3 + 2[!java|c];[/!]
x = 3 * x[!java|c];[/!]
[!java|scala|python]saudação = "Oi "+nome[!java];[/!] <span class="comment">[!python]#[/!][!scala|java]//[/!] + é (também) a operação para concatenar (ie, para juntar) cadeias[/!]</span></pre> 

<h3>Objetivo do exercício</h3>
Agora vamos fazer exercícios mais desafiantes, certo? O objetivo agora é
mover para a frente até encontrar um baggle, apanhar-lo e mover para trás
até a localização inicial antes de sotar o baggle.

<h3>Como fazer isto?</h3> 
<p>Para resolver este problema, tem que decompor-lo em sub-partes menores. Por
exemplo, pode fazer os passos seguintes:
<ol>
  <li>Mover para a frente até se pôr sobre um baggle</li>
  <li>Apanhar o baggle</li>
  <li>Mover para trás a mesma quantidade de passos que deu no primeiro passo</li>
  <li>Soltar o baggle de novo</li>
</ol></p>

<p>Naturalmente, é impossível dar a quantidade certa de passos para trás no
passo 3 se não contou a quantidade de passos dados na primeira fase. Pode
usar uma variável para isto, que pode ser chamada
<code>quantidadeDePassos</code>.</p>

<p>Crie uma variável inteira antes da fase 1, inicie ela com 0 e a cada vez que
der um passo para frente, incremente ela de um (<code>quantidadeDePassos =
quantidadeDePassos + 1;</code>[!java] ou <code>quantidadeDePassos++;</code>,
ambas as sintaxes são equivalentes[/!]).  Tais variáveis que obtèm cada
valor de um dado intervalo são normalmente chamadas de <b>stepper</b>.</p>
  
[!python|scala]
<p>Se conhece Java ou outras linguagens, provavelmente vai tentar usar o
operador <code>++</code> para incrementar a variável, mas isto não é
permitido em [!thelang].  Isto é por que seria difícil definir este operador
para todos os tipos de dados.  Por exemplo, o que faria ++ quando aplicado a
um valor complexo ou a uma cadeia? O problema não ocorre em Java, pois
<code>int</code> não é um objeto e sim um tipo primitivo.  (se não conhece o
<code>++</code>, simplesmente ignore este parágrafo: fnão existe em
[!thelang])</p>
[/!]

<p>Então, a fase 3 consiste em simplesmente criar uma nova variável inteira
<code>passosDados</code> iniciada como 0 e dar um passos para trás enquanto
<code>passosDados</code> não for igual a <code>quantidadeDePassos</code>, a
aumentar <code>passosDados</code> a cada vez. O operador <code>!=</code>
deve ser usado para testar a inequação (quando um valor NÃO É igual).</p> 

<p>Agora é a sua vez!</p>

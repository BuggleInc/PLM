<h1>Knitting and Arrays</h1>

The goal of this exercise is to reproduce the pattern of the first row in
the other rows with a shift of one cell (see the Objective tab for
details). The biggest difference between this exercise and the other we had
on patterns is that you have to read the pattern (on first row) before
reproducing it. You cannot do otherwise because the same code will be
executed on three different worlds, each of them having its specific
pattern.

<p>One solution is to read the next cell, and go copy it in position before
comming back to read the second cell. But since it is forbiden to use the
methods to teleport the buggle to a specific position (<code>setPos()</code>
and similar), this approach will be a pain to implement. </p>
 
<p>The simplest is to store the whole color pattern in an <b>array</b>.

<h2>Arrays in Java</h2> 
An array is a sequence of positions in which one can store values of the
same kind (one value per cell). It is thus a sequence of values of the same
kind:</p>

<br>
<table border="0">
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T&nbsp;&nbsp;&nbsp;&nbsp;</td>
          <td border="1">3</td><td border="1">7</td><td border="1">13</td>
          <td border="1">8</td><td border="1">15</td><td border="1">6</td>
          <td border="1">11</td><td border="1">10</td><td border="1">9</td>
</tr>
</table>

<p>T is the array's name, T[0] is the name of the first cell, T[1] the name of
the second cell, T[2] the third one, etc. And yes, the first cell in
numbered T[0] and the last one of an array of size N is T[N-1].</p>

<p>We can use an integer variable <i>i</i> to access with T[i] to the array's
cells: when the value of <i>i</i> is 0, then T[i] accesses T[0], when the
value of <i>i</i> is 10, then T[i] accesses T[10]. <i>i</i> is said to be
the indice in the array T.

<h2>Initializing an array</h2>
Let <code>T</code> be an array of 10 integer elements. It can then be
initialized this way:
<pre>
for (int i = 0; i&lt;10; i++) {
   T[i] = 3;
}
</pre>

<code>T[i]</code> can be used just like a variable. We can set a new value: 
<pre>T[i] = 78;</pre>

<p>We can access its value: 
<pre>x = T[i];</pre></p>

<p>We can test this value:
<pre>
if (T[i] > 0 ) {
    // instructions...
}
</pre></p>

<h3>Declaring an array</h3>
An array can be declared the following way:
<pre>int[] T;</pre>

<p><code>int</code> means that the elements of the array are of type integer;
<code>T</code> is the name of the array and <code>[]</code> means that we
are speaking of an array. It is also possible to declare the same array the
following way. Both writings are equivalent, but the first one is often
prefered in Java.
<pre>int T[];</pre></p>

<h3>Allocating an array</h3>

Declaring an array <code>T</code> only reserve the name <code>T</code> for
later use. But the array is not initialized yet: it does not have any
value. What would <code>T[4]</code> mean if we didn't say that the array is
at least 5 cells long?

<p>First and foremost, we have to give a value to <code>T</code>:
<pre>T = new int[10];</pre>
<code>new</code> means that we want to create something, and
<code>int[10]</code> means that it is an array of 10 integer values. In
return, an array of 10 integer cells is created in memory, and the
<code>T</code> variable reference this array.

<p>The size of an array is fixed and cannot be changed after the creation of
the array. To know the size of a <code>T</code> array, we can consult the
value of the variable <code>T.length</code>.</p>

<p>
It is forbidden to write:
<pre>int T[10]; // WRONG!!!</pre>
You are required to use the <code>new</code> instruction. On the other hand,
you perfectly can specify the size with a variable <code>i</code>.
<pre>T = new int[i];</pre>
In this case, the array's size will be set to the value of <code>i</code>
<b>when <code>new</code> gets called</b>. If the variable changes afterward,
it won't change the array's size.

<h4>Declaration and allocation</h4>
<pre>int[] T = new int[10];</pre>

We declare and allocate the array on the same line.

<h4>Declaration and initialization</h4>
<pre>int[] T = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };</pre>

We declare, allocate and initialize the array on the same line. To know the
size of the array to allocate, the compiler counts the provided values. This
code is equivalent to:
<pre>
int[] T = new int[10];
T[0] = 1;
T[1] = 2;
...
T[9] = 10;
</pre>

It is also equivalent to:
<pre>
int[] T = new int[10];
for (int i=0; i&lt;T.length; i++) {
  T[i] = i+1;
}
</pre>

<h3>Arrays and method parameters</h3>
It is perfectly ok to pass an array to a method as a parameter. The method
must have a prototype similar to:
<pre>void myMethod(int[] values) {
  // do something
}</pre>

On the caller side, that also very simple:
<pre>
int[] tab = new int[10];
// initalize the values
myMethod(tab);
</pre>

<p>We can also have methods returns arrays as results:
<pre>int[] otherMethod() {
  int[] result = new int[10];
  // do something
  return result;
}</pre>

<h2>Goal of this exercise</h2>
The <code>run()</code> method that you should write must declare an array of
colors (<code>Color[]</code>) and allocate it. Beware, the first world is
6x6, but this is not the case of the others. Use the
<code>getWorldHeight()</code> method to retrieve the amount of lines in the
current world.

<p>Once the array allocated, we have to fill it. For each cel of the row, read
the ground color (with <code>getGroundColor()</code>), and store it in the
right cell of the array.</p>

<p>Once hte array initialized, you have to reapply the pattern on every rows,
for example by excuting <code>getWorldHeight()</code> times a method written
specifically for this.</p> 

<p>You're up.</p>


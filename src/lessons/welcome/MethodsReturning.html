<h2>Methods returning a result</h2>

Writing a method returning a result is not really more work than writing a
method without any result. You simply have to specify the data type of
expected results before the method name, and then write a
<code>return</code> instruction in your method body to specify the actual
value to return.

<pre>double pi() {
&nbsp;&nbsp;&nbsp;&nbsp;return 3.14159;
}
boolean isNumberTwoEven() {
&nbsp;&nbsp;&nbsp;&nbsp;return true;
}
</pre>

<p>It is possible to have several <code>return</code> instructions in several
branches of a conditional. It is even forbiden to have one execution path of
your body without any <code>return</code>, or to write some code after the
<code>return</code> instruction.</p>

<p>Indeed, if the machine reaches the end of the method without finding any
<code>return</code>, it cannot know what actual value to give back to the
method caller. Moreover, <code>return</code> interrupts immediately the
method execution (why bother looking further when you know the method
result?). So, if there is some code after a <code>return</code>, it must be
an error and the compiler warns you.</p>

<pre>boolean negation(boolean cond) {
&nbsp;&nbsp;&nbsp;&nbsp;if (cond == true) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">/* no code allowed here */</span>
&nbsp;&nbsp;&nbsp;&nbsp;} else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">/* here neither */</span>
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">/* even here, forget it */</span>
}</pre>


<h3>Exercise goal</h3>You will once again write a method that the buggle will use. Its name must
be <code>haveBaggle</code>, and it returns a boolean value indicating
whether the row in front of the buggle contains a baggle or not. The buggle
will use it to search the first row containing a baggle, and stop here.

<p>The easier for this method is to use a boolean variable called
<code>seenBaggle</code> indicating whether or not we saw a baggle so far. It
initial value is 'false'.</p>

<p>Then, move 6 steps forward (the world contains 7 cells and we already are
one one of them). For each cell, if it contains a baggle, we store true in
<code>sawBaggle</code> (and we don't do anything but moving forward if not).</p>

<p>At the end, we move back by 6 steps, and we return the value of
<code>seenBaggle</code> to the caller.</p>


<p>This exercise is a bit different since there is two initial worlds, each
with a specific objective. Your code must work for each of them. Observe
that the world selection scrolling menu (right below the speed slider)
allows to switch the observed world. </p>

<p>When your method <code>haveBaggle</code> works, proceed to next exercise.</p>


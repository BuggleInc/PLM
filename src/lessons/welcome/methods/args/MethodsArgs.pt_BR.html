
<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->
<h2>Métodos com perâmetros</h2>

<p>Você não está cansado de escrever o mesmo código várias vezes para se
mover uma certa quantidade de passos? Por outro lado, escrever
<tt>avançar2()</tt>, <tt>avançar3()</tt>, <tt>avançar4()</tt>, assim
como <tt>recuar2()</tt>, <tt>recuar3()</tt>, <tt>recuar4()</tt> e etc
também não ajudam, para dizer o mínimo.</p>

<p>Luckily, it is possible to pass <b>parameters</b> to your methods. You have
to specify their type and name between the parenthesis after the method
name. Then, you can use them in the method body as if it were variables
defined in there, and which initial value is what the caller specified.</p>

<pre>[!java]double [/!]divideByTwo([!java]double [/!]x[!scala]: Double[/!])[!scala]: Double =[/!] [!java|scala]{[/!][!python]:[/!]
     return x / 2[!java];[/!]
[!scala|java]}[/!]</pre>

<p>As caller, you have to specify the initial value of this "variables" between
the call's parenthesis.</p>
<pre>[!java]double [/!][!scala]val [/!]result = divideByTwo(3.14)[!java];[/!]</pre>

<p>If you want several parameters, you need to separate them with comas (,)
both in the declaration and calls.</p>

<pre>[!java]double divide(double x, double y) {[/!]
[!scala]def divide(x:Double, y:Double): Double = {[/!]
[!python]def divide(x, y):[/!]
     return x / y[!java];[/!]
[!java|scala]}[/!]</pre>
<pre>[!java]double res = divide(3.14 , 1.5);[/!]
[!scala]val res = divide(3.14 , 1.5)[/!]
[!python]res = divide(3.14 , 1.5)[/!]</pre>

[!java|scala]
<p>In [!thelang], you can declare several methods of the same name as long as
they don't have the same <b>signature</b>, that is, the same amount of
parameters and the same parameters' types.</p>

<pre>[!java]double max(double x, double y)[/!][!scala]def max(x:Double, y:Double): Double =[/!] {
  if (x > y) {
    return x;
  }
  return y;
}[!java]int max(int x, int y)[/!][!scala]def max(x:Int, y:Int): Int =[/!] {
  if (x > y) {
    return x;
  }
  return y;
}
[!java]int max(int x, int y; int z)[/!][!scala]def max(x:Int, y:Int, z:Int): Int =[/!] {
  if (x > y && x > z) {
    return x;
  }
  if (y > z) {
    return y;
  }
  return z;
}</pre>

<p>Observe that we omitted the <tt>else</tt> branches of each <tt>if</tt>. It
works anyway because a <tt>return</tt> interrupts the method execution. If
we arrive to the last line of
<code>[!java]max(int,int)[/!][!scala]max(Int,Int):Int[/!]</code>, we know
that <code>x&lt;=y</code> because otherwise, the <tt>return</tt> of line 2
would have stopped the execution.</p>
<!-- introduce default value for parameters in Python language -->
[/!]



<h3>Objetivo do exercício</h3>
<p>This time, you have to write a <code> [!java]move(int stepCount,boolean
forward)[/!] [!scala]move(stepCount: Int,forward: Boolean)[/!]
[!python]move(stepCount,forward)[/!] </code> method which moves forward by
<code>stepCount</code> steps if <code>forward</code> is true, and moves back
of that amount of steps if the boolean is false.</p>

<p>This time, there is only one world but seven buggles, all sharing the same
code.  This code should not be really problematic for you to write,
actually.</p>

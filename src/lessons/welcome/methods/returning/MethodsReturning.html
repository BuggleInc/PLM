<h2>Methods returning a result</h2>

Writing a method returning a result is not really more work than writing a
method without any result. <span class="Java">You simply have to specify the data type of
expected results before the method name</span>. And, then write a
<code>return</code> instruction in your method body to specify the actual
value to return.

<pre class="Java">double pi() {
&nbsp;&nbsp;&nbsp;&nbsp;return 3.14159;
}
boolean isNumberTwoEven() {
&nbsp;&nbsp;&nbsp;&nbsp;return true;
}
</pre>
<pre class="Python">def pi():
&nbsp;&nbsp;&nbsp;&nbsp;return 3.14159

def isNumberTwoEven():
&nbsp;&nbsp;&nbsp;&nbsp;return True
</pre>

<p>It is possible to have several <code>return</code> instructions in several
branches of a conditional. It is even forbidden to have one execution path of
your body without any <code>return</code>, or to write some code after the
<code>return</code> instruction.</p>

<p>Indeed, if the machine reaches the end of the method without finding any
<code>return</code>, it cannot know what actual value to give back to the
method caller. Moreover, <code>return</code> interrupts immediately the
method execution (why bother looking further when you know the method
result?). So, if there is some code after a <code>return</code>, it must be
an error and the compiler warns you.</p>

<pre class="Java">boolean negation(boolean cond) {
&nbsp;&nbsp;&nbsp;&nbsp;if (cond == true) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">/* no code allowed here */</span>
&nbsp;&nbsp;&nbsp;&nbsp;} else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">/* here neither */</span>
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">/* even here, forget it */</span>
}</pre>
<pre class="Python">def negation(cond):
&nbsp;&nbsp;&nbsp;&nbsp;if cond == True:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return True
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment"># no code allowed here</span>
&nbsp;&nbsp;&nbsp;&nbsp;else:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return False
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment"># here neither</span>
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment"># even here, forget it</span>
</pre>

<h3>Exercise goal</h3>You will once again write a method that the buggle will use. Its name must
be <code>haveBaggle</code>, and it returns a boolean value indicating
whether the row in front of the buggle contains a baggle or not. The buggle
will use it to search the first row containing a baggle, and stop here.

<p>The easier for this method is to use a boolean variable called
<code>seenBaggle</code> indicating whether or not we saw a baggle so far. It
initial value is 'false'.</p>

<p>Then, move 6 steps forward (the world contains 7 cells and we already are
one one of them). For each cell, if it contains a baggle, we store true in
<code>sawBaggle</code> (and we don't do anything but moving forward if not).</p>

<p>At the end, we move back by 6 steps, and we return the value of
<code>seenBaggle</code> to the caller.</p>


<p>This exercise is a bit different since there is two initial worlds, each
with a specific objective. Your code must work for each of them. Observe
that the world selection scrolling menu (right below the speed slider)
allows to switch the observed world. </p>

<p>When your method <code>haveBaggle</code> works, proceed to next exercise.</p>


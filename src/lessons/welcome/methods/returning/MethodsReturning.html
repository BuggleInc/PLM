<!-- Please don't translate this file but lib/l10n/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->
<h2>Methods returning a result</h2>

<p>Writing a method returning a result is not really more work than writing a
method without any result. 
[!java]You simply have to specify the data type of expected results before the method name (where we previously had <code>void</code>).[/!]
[!scala]You simply have to add a column (:) after the parenthesis and write the type of data that your method will return, and add an equal sign (=). This syntax is actually rather
close to defining a variable, with its type, that is actually a function.[/!]
You can use the <code>return</code> instruction anywhere in your method body to 
specify that the computation is done (the method is not further executed), and that 
the result is the the value following the <code>return</code> keyword.</p>

<pre>[!java]double pi() {[/!][!scala]def pi(): Double = {[/!][!python]def pi():[/!]
    return 3.14159[!java];[/!]
[!java|scala]}[/!]</pre>

<p>Actually, you can also use that <code>return</code> keyword in methods that do not return any result, to interupt the computation. Of course, you should not provide any
value to return in that case.</p>

<p>It is possible to have several <code>return</code> instructions in several
branches of a conditional. In fac, it is forbidden to have any execution path of
your body without any <code>return</code>, or to write some code after the
<code>return</code> instruction. Indeed, if the machine reaches the end of the 
method without finding any <code>return</code>, it cannot know what actual 
value to give back to the method caller. 
Moreover, <code>return</code> interrupts immediately the method execution 
(why bother looking further when you know the method result?). So, if there is 
some code after a <code>return</code>, it must be an error and the compiler 
warns you.</p>

<pre>[!java|scala][!java]boolean [/!][!scala]def [/!]isFrontFree()[!scala]:Boolean =[/!] {
    if (isFacingWall() == true) {
        return false;
        <span class="comment">/* no code allowed here */</span>
    } else {
        return true;
        <span class="comment">/* here neither */</span>
    }
    <span class="comment">/* even here, forget it */</span>
}[/!][!python]def isFrontFree():
    if isFacingWall() == True:
        return False
        <span class="comment"># no code allowed here</span>
    else
        return True
        <span class="comment"># here neither</span>
<span class="comment"># even here, forget it</span>[/!]</pre>

<h3>Exercise goal</h3>You will once again write a method that the buggle will use. Its name must
be <code>haveBaggle</code>, and it returns a boolean value indicating
whether the row in front of the buggle contains a baggle or not. The buggle
will use it to search the first row containing a baggle, and stop here.

<p>The easier for this method is to use a boolean variable called
<code>seenBaggle</code> indicating whether or not we saw a baggle so far. It
initial value is 'false'.</p>

<p>Then, move 6 steps forward (the world contains 7 cells and we already are
one one of them). For each cell, if it contains a baggle, we store true in
<code>sawBaggle</code> (and we don't do anything but moving forward if not).</p>

<p>At the end, we move back by 6 steps, and we return the value of
<code>seenBaggle</code> to the caller.</p>


<p>This exercise is a bit different since there is two initial worlds, each
with a specific objective. Your code must work for each of them. Observe
that the world selection scrolling menu (right below the speed slider)
allows to switch the observed world. </p>

<p>When your method <code>haveBaggle</code> works, proceed to next exercise.</p>


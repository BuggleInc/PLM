
<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->
<h2>Funções</h2>

<p>Frequentemente, você vai querer escrever um método que calcula algum valor e
o retorna. Métodos retornando resultados são chamados
<b>funções</b>. Escrever uma função não é realmente mais difícil do que
escrever um simples método.  [!java|c]Você simplesmente tem que especificar
o tipo de dados do resultado esperado entes do nome da função (onde nós
previamente tínhamos <code>void</code>).[/!] [!scala]Você simplesmente tem
que adicionar um dois-pontos (:) depois do parêntesis e escrever o tipo de
dados que sua função vai retornar, e adicionar um símbolo de igualdade
(=). Esta sintaxe é na verdade mais próxima de definir uma variável, com seu
tipo, do que na verdade escrever uma função.[/!] Você pode usar a instrução
<code>return</code> em qualquer lugar do corpo da sua função para
especificar que o cálculo foi feito (a função não continuará sendo
executada), e que o resultado é o valor que acompanha a palavra-chave
<code>return</code>.</p>

<pre>[!java|c]double pi() {[/!][!scala]def pi(): Double = {[/!][!python]def pi():[/!]
    return 3.14159[!java|c];[/!]
[!java|scala|c]}[/!]</pre>

<p>Na verdade, você também pode usar a palavra-chave <code>return</code> em
métodos que não retornam qualquer resultado, para interromper o
cálculo. Obviamente que nestes casos você não passa nenhum valor para
retornar.</p>

<p>É possível ter várias instruções <code>return</code> em várias ramificações
de um condicional. De fato, é proibido ter um caminho de execução no corpo
da função sem nenhum <code>return</code>, ou escrever algum código depois da
instrução <code>return</code>. Na verdade, se a máquina alcança o fim da
função sem encontrar qualquer <code>return</code>, ela não sabe o real valor
que deve retornar a quem chamou a função. Além disto, o <code>return</code>
interrompe imediatamente a execução da função (por que se preocupar olhando
além quando você sabe o resultado da função?). Então, se existe algum código
depois de um <code>return</code>, deve ser um erro e o compilador irá te
alertar disto.</p>

<pre>[!java|scala|c][!java]boolean [/!][!c]int [/!][!scala]def [/!]isFrontFree()[!scala]:Boolean =[/!] {
    if (estáDeFrenteParaParede() == [!java|scala]true[/!][!c]1[/!]) {
        return [!java|scala]false[/!][!c]0[/!];
        <span class="comment">/* proibido colocar código aqui */</span>
    } else {
        return [!java|scala]true[/!][!c]1[/!];
        <span class="comment">/* nem aqui */</span>
    }
    <span class="comment">/* e nem mesmo aqui. desista */</span>
}[/!][!python]def livreEmFrente():
    if estáDeFrenteParaParede() == True:
        return False
        <span class="comment"># proibido colocar código aqui</span>
    else
        return True
        <span class="comment"># nem aqui</span>
<span class="comment"># e nem mesmo aqui, desista</span>[/!]</pre>

<h3>Objetivo do exercício</h3>Você vai mais uma vez escrever uma função que o buggle vai usar. Seu nome
deve ser <code>temBaggle</code>, e ela retorna um valor booleano indicando
se a linha na frente do buggle contém um baggle ou não. O buggle vai usar
isto para buscar a primeira linha contendo um baggle, e parar nela.

<p>A forma fácil de fazer esta função é usar uma variável booleana chamada
<code>baggleAvistado</code> indicando se nós vimos ou não um baggle até o
momento. O valor inicial é
'[!python]False[/!][!scala|java]false[/!][!c]0[/!]'.</p>

<p>Então mova 6 passos para frente (o mundo contém 7 células e nós já estamos
em uma delas). Para cada célula, se ela contiver um baggle, vamos guardar
true em <code>baggleVisto</code> (e se não, vamos simplesmente andar para
frente).</p>

<p>No final, vamos nos mover 6 passos para trás, e retornar o valor de
<code>baggleVisto</code> para quem chamou o método.</p>

<p>Note that the used buggle provides some hidden code that will call your
<code>haveBaggle</code> function on each column, moving automatically
between columns. It is thus very important that your <code>haveBaggle</code>
function have no side effect: the position (and orientation) at the end of
your code must be the one observed at the beginning of this code. It will
move in between to seek for the baggle, but come back to the column start.</p>

<p>Also, this exercise is a bit different since there is two initial worlds,
each with a specific objective. Your code must work for each of
them. Observe that the world selection scrolling menu (right below the speed
slider)  allows to switch the observed world. </p>

<p>Quando sua função <code>temBaggle</code> funcionar, siga para o próximo
exercício.</p>


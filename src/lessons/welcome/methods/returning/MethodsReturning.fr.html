
<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->
<h2>Fonctions</h2>

<p>Souvent, on souhaite écrire une méthode calculant une valeur donnée, et qui
la retourne. On appelle <b>fonctions</b> ces méthodes qui renvoient un
résultat.Écrire une fonction n'est pas tellement plus dur que pour les
méthodes sans résultat.
[!java|c]Il suffit d'écrire le type de données renvoyées par votre fonction
avant son nom (là où nous écrivions <code>void</code> avant).[/!]
[!scala]Il suffit d'ajouter deux points (:), le type de données renvoyées
par votre fonction et le signe égal (=) entre  les parenthèses de la
déclaration et l'accolade du bloc. Cette syntaxe est assez proche de la
définition d'une variable (avec son type) dont la valeur serait une
fonction.[/!]
Vous pouvez utiliser l'instruction <code>return</code> n'importe ou dans le
corps de votre fonction pour spécifier que le calcul est fini (la suite de
la fonction n'est pas exécutée) et donner la valeur à donner à l'appelant
après le mot-clé <code>return</code>.</p>

<pre>[!java|c]double pi() {[/!][!scala]def pi(): Double = {[/!][!python]def pi():[/!]
    return 3.14159[!java|c];[/!]
[!java|scala|c]}[/!]</pre>

<p>En fait, vous pouvez également utiliser le mot-clé <code>return</code> dans
les méthodes ne renvoyant pas de résultat, pour interrompre leur
exécution. Dans ce cas, il ne faut bien entendu pas donner de valeur à
droite du <code>return</code>.</p>

<p>Il est possible d'avoir plusieurs instructions <code>return</code> dans
différentes branches de <code>if</code>. Ce qui est interdit, c'est d'avoir
une branche du code qui n'est pas terminée par un <code>return</code>, ou
d'écrire du code après le <code>return</code>.
En effet, si la machine arrive à la fin de la fonction sans avoir rencontré
de <tt>return</tt>, elle ne peut pas savoir quelle valeur communiquer à
celui qui a appelé la fonction. De plus, le <tt>return</tt> interrompt
immédiatement l'exécution de la fonction (pourquoi continuer à chercher
quand on a déjà trouvé le résultat de la fonction?). Donc, s'il y a du code
après un <tt>return</tt>, c'est sans doute une erreur, et le compilateur
vous l'indique.</p>

<pre>[!java|scala|c][!java][!java]boolean [/!][!c]int [/!] [/!][!scala]def [/!]estDevantLibre()[!scala]:Boolean =[/!] {
    if (estFaceMur() == [!java|scala]true[/!][!c]1[/!]) {
        return [!java|scala]false[/!][!c]0[/!];
        <span class="comment">/* interdit d'écrire du code ici */</span>
    } else {
        return [!java|scala]true[/!][!c]1[/!];
        <span class="comment">/* pareil ici */</span>
    }
    <span class="comment">/* même ici, oubliez */</span>
}[/!][!python]def estDevantLibre():
    if estFaceMur() == True:
        return False
        <span class="comment"># interdit d'écrire du code ici</span>
    else
        return True
        <span class="comment"># pareil ici</span>
<span class="comment"># même ici, oubliez</span>[/!]</pre>

<h3>Objectif de cet exercice</h3>Vous allez encore une fois écrire une fonction qui sera utilisée par la
buggle. Son nom doit être <code>haveBaggle</code>, et elle doit renvoyer un
booléen indiquant si la colonne face à la buggle contient un biscuit ou
non. Votre buggle va s'en servir pour chercher la première colonne contenant
un biscuit et s'y arrêter.

<p>Le plus simple pour écrire cette fonction est peut être d'utiliser une
variable booléenne <code>vuBiscuit</code> indiquant si on a vu un biscuit
jusque là. Initialement, elle contient faux
(«[!python]False[/!][!scala|java]false[/!][!c]0[/!]»).</p>

<p>Ensuite, on avance de 6 cases (le monde contient 7 cases, et on est déjà sur
l'une d'entre elles). Pour chaque case, si elle contient un biscuit, on
range la valeur vrai dans <tt>vuBiscuit</tt> (et on ne fait rien d'autre
qu'avancer si non).</p>

<p>Quand on est arrivé à la fin, on recule de 6 cases, et on retourne le
contenu de <tt>vuBiscuit</tt> à l'appelant.</p>


<p>Cet exercice est un peu particulier, puisqu'il a deux mondes initiaux,
chacun ayant un objectif particulier. Votre code doit fonctionner pour
chacun d'entre eux. Remarquez que le menu déroulant de sélection du monde
(juste sous la barre de réglage de la vitesse) permet de spécifier le monde
que vous souhaitez observer. </p>

<p>Quand votre fonction <tt>haveBaggle</tt> fonctionne, passez à l'exercice
suivant.</p>


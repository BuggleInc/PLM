<h2>Méthodes retournant un résultat</h2>

Écrire des méthodes retournant un résultat n'est pas bien plus compliqué
qu'écrire une méthode n'en renvoyant pas. <span class="Java"> Vous devez
simplement indiquer le type du résultat attendu avant le nom de la
méthode</span>. Il faut écrire dans le corps de la méthode une instruction
<code>return</code> qui précise la valeur à renvoyer.

<pre class="Java">double pi() {
&nbsp;&nbsp;&nbsp;&nbsp;return 3.14159;
}
boolean deuxEstIlPair() {
&nbsp;&nbsp;&nbsp;&nbsp;return true;
}
</pre>
<pre class="Python">def pi():
&nbsp;&nbsp;&nbsp;&nbsp;return 3.14159

def deuxEstIlPair():
&nbsp;&nbsp;&nbsp;&nbsp;return True
</pre>

<p>Il est possible d'avoir plusieurs instructions <code>return</code> dans
différentes branches de <code>if</code>. Ce qui est interdit, c'est d'avoir
une branche du code qui n'est pas terminée par un <code>return</code>, ou
d'écrire du code après le <code>return</code>.</p>

<p>En effet, si la machine arrive à la fin de la méthode sans avoir rencontré
de <tt>return</tt>, elle ne peut pas savoir quelle valeur communiquer à
celui qui a appelé la méthode. De plus, le <tt>return</tt> interrompt
immédiatement l'exécution de la méthode (pourquoi continuer à chercher quand
on a déjà trouvé le résultat de la méthode?). Donc, s'il y a du code après
un <tt>return</tt>, c'est sans doute une erreur, et le compilateur vous
l'indique.</p>

<pre class="Java">boolean negation(boolean cond) {
&nbsp;&nbsp;&nbsp;&nbsp;if (cond == true) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">/* interdit d'écrire du code ici */</span>
&nbsp;&nbsp;&nbsp;&nbsp;} else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">/* ici aussi */</span>
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">/* même ici */</span>
}</pre>
<pre class="Python">def negation(cond):
&nbsp;&nbsp;&nbsp;&nbsp;if cond == True:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return True
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment"># interdit d'écrire du code ici</span>
&nbsp;&nbsp;&nbsp;&nbsp;else:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return False
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment"># ici aussi</span>
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment"># même ici</span>
</pre>

<h3>Objectif de cet exercice</h3><a name="Objectifs"> Vous allez encore une fois écrire une méthode qui sera
utilisée par la buggle. Son nom doit être <code>haveBaggle</code>, et elle
doit renvoyer un booléen indiquant si la colonne face à la buggle contient
un baggle ou non. Votre buggle va s'en servir pour chercher la première
colonne contenant un baggle et s'y arrêter.

<p>Le plus simple pour écrire cette méthode est peut être d'utiliser une
variable booléenne <code>vuBaggle</code> indiquant si on a vu un baggle
jusque là. Initialement, elle contient faux.</p>

<p>Ensuite, on avance de 6 cases (le monde contient 7 cases, et on est déjà sur
l'une d'entre elles). Pour chaque case, si elle contient un baggle, on range
la valeur vrai dans <tt>vuBaggle</tt> (et on ne fait rien d'autre qu'avancer
si non).</p>

<p>Quand on est arrivé à la fin, on recule de 6 cases, et on retourne le
contenu de <tt>vuBaggle</tt> à l'appelant.</p>


<p>Cet exercice est un peu particulier, puisqu'il a deux mondes initiaux,
chacun ayant un objectif particulier. Votre code doit fonctionner pour
chacun d'entre eux. Remarquez que le menu déroulant de sélection du monde
(juste sous la barre de réglage de la vitesse) permet de spécifier le monde
que vous souhaitez observer. </p>

<p>Quand votre méthode <tt>haveBaggle</tt> fonctionne, passez à l'exercice
suivant.</p>


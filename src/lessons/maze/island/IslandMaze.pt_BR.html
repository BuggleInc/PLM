
<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->
<h2>Lost between islands</h2>

<p>You thought that your algorithm was enough to escape mazes? Well, not every
mazes...
</p>

<p>The <i>wall follower algorithm</i> we used so far only works if the entry
and the exit are placed near to walls connected to the external wall. But if
the buggle begins in the middle of the maze, it may exist wall sections
disconnected from the external wall.

<p>That is why the previous strategy would let the buggle round around for
ever. Indeed, the maze you should now escape from contains islands, and the
buggle does not start along one of the external walls. Just give it a try if
you want: copy your code over, push the run button and see your previous
solution failing miserabily.</p>

<p>The method of following a wall is still good and allow to escape very
efficiently some sections of the maze, so we do not want to remove it
entierely. Instead, we want to stop following the wall under some
conditions. Notice that the baggle lays near to the external border of the
maze. So, we want to reach the border and then follow that wall. We need for
example to search for the north wall before following it to the baggle.

<p>To find the north wall, you simply run to the north as long as it's
possible, and when facing an obstacle, you avoid it (using previous method).</p>

<div class="tip" id="tip-1" alt="I'm lost now, please give me some extra indications">
	Our new run() method will consist in two modes: our buggle will alternate
between the "north runner mode" and the "left follower mode". You begin in
"north runner mode", and switch to "left follower" when you have a wall at
the north (do not forget to make sure you have a wall at your left before
switching to "left follower" mode). You switch to "north runner" as soon as
your buggle is facing north and is not in front of a wall during its trip
around its left wall. The easiest way to write such a state machine is
something like 
<pre>[!scala]var state=0;
state match  {
  case 0 => // North runner
     ...
     state = 1;
  case 1 => // Left follower
     ...
     state = 0;
  case _ => println("This case should not happen. Please fix me")
}[/!][!java|c]int state=0;
switch (state) {
  case 0: // North runner
     ...
     state = 1;
     break;
  case 1: // Left follower
     ...
     state = 0;
     break;
}[/!][!python]northRunner = True
if northRunner:
     ...
     northRunner = False
else: # left follower
     ...
     northRunner = True[/!]</pre>
     
[!scala]<br/>Don't forget the default case (matching _), or scala will issue an error
since your matching would be incomplete.[/!]
</div>
	
<p>Don't forget to let the buggle pick the baggle at the end of your code.</p>
	
	
<p>You're up. That should be enough for you to figure out how to escape this
maze, but if not, you can always request for the tip. But you do not need
any more help, do you?</p>

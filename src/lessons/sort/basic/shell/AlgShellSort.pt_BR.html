
<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->
<h2>ShellSort</h2>
 
This algorithm is named after its author, Donald Shell, who published it in
1959. It can be seen as an application of the CombSort idea (let elements
having a long path to travel take shortcuts) to the insertion sort (CombSort
is a variation of BubbleSort). Instead of comparing adjacent values during
the insertion sort, it compares values separated by a bigger gap. The bigger
the gap, the faster the elements are moved to their final destination, but
also the less precise is this move. It is thus mandatory to apply the
algorithm with a serie of decreasing gaps. At the last step, when the gap is
one, InsertionSort is used, but onto an array which is almost already sorted
by previous steps.

<p>Donald Shell propôs <code>len/2</code> como o valor inicial do
intervalo, e ir dividindo por 2 a cada passo. O pseudo-código é o
seguinte:
<pre>
gap=len/2
while gap>0:
  apply InsertionSort, comparing i-gap and i, then i-2gap and i-gap, then i-3gap and i-2gap, etc.
</pre>

<p>Assim como no CombSort, a sequência de valores pega pelo intervalo é
crucial para a performance do Shell sort. Em alguns casos patológicos
raros, a sequência que usamos pode levar a uma performance
O(n^2). Outras sequências foram propostas: os incrementos de Hibbard
de 2k − 1 levam a uma complexidade de O(n^(3/2)) em casos
ruins. incrementos de Pratt 2^i3^j levam a uma performance de
O(nlog(n)log(n) nos piores casos. A existência de uma sequência
levando a O(n log(n)) foi excluída por Poonen, Plaxton e Suel. Graças
a esta performance, ShellSort é um candidato válido para arrays de
várias centenas de milhares quando corretamente implementado.</p>

<p>No nosso caso, a array é pequena demais para se beneficiar destas
otimizações. Se você ainda assim quiser, tome o intervalo inicial como
o maior valor da série alvo ainda menor que o tamanho do array, e
então use valores decrescentes da série.</p>

<p>Determinar a melhor sequência de intervalos para o shell sort se
tornou um tema de pesquisa de nosso século em ciência da
computação. Por exemplo, um artigo de 2001 introduz a seguinte
sequência, que parece ser a melhor na prática para arrays de tamanho
até 10^5: {1, 4, 10, 23, 57, 132, 301, 701, 1750} (Marcin Ciura, Best
Increments for the Average Case of Shellsort, 13th International
Symposium on Fundamentals of Computation Theory, LNCS 2001;
Vol. 2138).</p> 

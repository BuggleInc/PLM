
<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->
<h1>Sorting World </h1>
This world provides tools to experiment with the sorting algorithms. It can
be used in two different ways: the first one is naturally to write the
required sorting algorithms. But it is also possible to simply use the demo
mode of each exercise to observe the behavior of sorting algorithms. It
helps understanding the differences between each of them.

<h2>Methods available to sorting algorithms</h2>
<table border=1>
<tr><td><b>Метод</b></td><td><b>Дія</b></td><td><b>Вартість</b></td></tr>
<tr><td>[!java|c]int [/!]getValueCount() [!scala]:Int[/!]</td>
    <td>Returns the amount of values in the array</td><td>немає</td></tr>

<tr><td>[!java]boolean [/!][!c]int [/!]isSmaller([!java|c]int [/!]i[!scala]:Int[/!],
[!java|c]int [/!]j[!scala]:Int[/!]) [!scala]:Boolean[/!]</td>
    <td>Returns true if the content of cell i is strictly smaller than the one of
cell j</td><td>two reads</td></tr>
<tr><td>[!java]boolean [/!][!c]int [/!]isSmallerThan([!java|c]int
[/!]i[!scala]:Int[/!], [!java|c]int [/!]value[!scala]:Int[/!])[!scala]
:Boolean[/!]</td>
    <td>Returns true if the content of cell i is strictly smaller than the
<code>value</code></td><td>one read</td></tr>

<tr><td>[!java|c]void [/!]swap([!java|c]int [/!]i[!scala]:Int[/!], [!java|c]int
[/!]j[!scala]:Int[/!])</td>
     <td>Swaps the content of cell i and the one of cell j</td><td>two reads, two writes</td></tr>
<tr><td>[!java|c]void [/!]copy([!java|c]int [/!]from[!scala]:Int[/!], [!java|c]int
[/!]to[!scala]:Int[/!])</td>
    <td>Copy the content of cell 'from' into the cell 'to'</td><td>one read, one write</td></tr>

<tr><td>[!java|c]int [/!]getValue([!java|c]int [/!]idx[!scala]:Int[/!])</td>
    <td>Returns the value of cell idx</td><td>one read</td></tr>
<tr><td>[!java|c]void [/!]setValue([!java|c]int [/!]idx[!scala]:Int[/!],
[!java|c]int [/!]value[!scala]:Int[/!])</td>
    <td>Sets cell 'idx' to the <code>value</code> </td><td>one write</td></tr>

<tr><td>[!java]boolean [/!][!c]int [/!]isSelected() [!scala]:Boolean[/!]</td>
    <td>Returns whether the current world is selected in the graphical interface.</td><td>немає</td></tr>

</table>

<h2>Панель журналу</h2>
<p>It is not enough to sort the array to pass the exercises. Your solution must
strictly follow the expected behavior of each exercise. This is enforced by
checking that your algorithm needs the same amount of read and write
operations to sort the array. When they don't match, understanding the
difference between your code and the expected solution can reveal very
difficult.</p>

<p>To help in this process, it is possible to graphically explore the history
of your sorting algorithm. Switch to the Objective view and use the
contextual menu (right click) to switch from the view of the current state
to the view of its history.</p>

<p>The history view is a bit hairly at the first glance, but actually rather
simple: The time flows from left to right on this graph, and each row is a
cell of your array. The curved lines that go navigate between rows represent
a given data value. When two lines cross, this means that two values were
swapped at this time stamp; A line fork represent a value copy; When a value
is magenta and followed by an interrogation mark (?), it was read using
getValue(); If the value is red and followed with an exclamation point (!),
it was written using setValue().</p>

<p>This view, inspired from Aldo Cortesi, reveals very helpful understand the
inner behavior of sorting algorithms.</p> 


<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->
<h1>Mundo da ordenação </h1>
Este mundo fornece ferramentas para experimentar com algoritmos de
ordenação. Ele pode ser usado de duas formas diferentes: a primeira é
naturalmente para escrever os algoritmos de ordenação necessários. Mas
também é possível simplesmente usar o modo de demonstração de cada exercício
para observar o comportamento de algoritmos de ordenação. Isto ajuda a
entender as diferenças entre cada um deles.

<h2>Métodos disponíveis para algoritmos de ordenação</h2>
<table border=1>
<tr><td><b>Método</b></td><td>Ação</td><td>Custo</td></tr>
<tr><td>[!java|c]int [/!]getQuantidadeDeValores() [!scala]:Int[/!]</td>
    <td>Retorna a quantidade de valores na array</td><td>nenhum</td></tr>

<tr><td>[!java]boolean [/!][!c]int [/!]éMenor([!java|c]int [/!]i[!scala]:Int[/!],
[!java|c]int [/!]j[!scala]:Int[/!]) [!scala]:Boolean[/!]</td>
    <td>Retorna verdadeiro se o conteúdo da célula i é estritamente menor que o da
célula j</td><td>duas leituras</td></tr>
<tr><td>[!java]boolean [/!][!c]int [/!]éMenorQue([!java|c]int [/!]i[!scala]:Int[/!],
[!java|c]int [/!]value[!scala]:Int[/!])[!scala] :Boolean[/!]</td>
    <td>Retorna verdadeiro se o conteúdo da célula i é estritamente menor que
<code>valor</code></td><td>uma leitura</td></tr>

<tr><td>[!java|c]void [/!]alternar([!java|c]int [/!]i[!scala]:Int[/!], [!java|c]int
[/!]j[!scala]:Int[/!])</td>
     <td>Alterna ("swap") o conteúdo da célula i com o da célula j</td><td>duas escritas, duas leituras</td></tr>
<tr><td>[!java|c]void [/!]copia([!java|c]int [/!]de[!scala]:Int[/!], [!java|c]int
[/!]para[!scala]:Int[/!])</td>
    <td>Copia o conteúdo da célula 'de' para a célula 'para'</td><td>uma leitura, uuma escrita</td></tr>

<tr><td>[!java|c]int [/!]getValor([!java|c]int [/!]idx[!scala]:Int[/!])</td>
    <td>Retorna o valor da célula idx</td><td>uma leitura</td></tr>
<tr><td>[!java|c]void [/!]setValor([!java|c]int [/!]idx[!scala]:Int[/!],
[!java|c]int [/!]valor[!scala]:Int[/!])</td>
    <td>Coloca na célula 'idx' o <code>valor</code> </td><td>uma escrita</td></tr>

<tr><td>[!java]boolean [/!][!c]int [/!]selecionado() [!scala]:Boolean[/!]</td>
    <td>Retorna verdadeiro se o mundo atual está selecionado na interface gráfica.</td><td>nenhum</td></tr>

</table>

<h2>Visão do histórico</h2>
<p>É suficiente ordenar a array para resolver os exercícios. Sua solução deve
seguir estritamente o comportamento esperado em cada exercício. Isto é
reforçado verificando que seu algoritmo precisa da mesma quantidade de
operações de leitura e escrita para ordenar a array. Quando estas
quantidades não coincidem, compreender a diferença entre seu código e a
solução esperada pode se mostrar bem difícil.</p>

<p>Para ajudar neste processo, é possível explorar graficamente o histórico do
algoritmo de ordenação. Alternar para a visão Objetivo e usar o menu de
contexto (clique com botão direito) para alternar da visão do estado atual
para a visão do histórico.</p>

<p>A visão do histórico é um pouco bagunçada à primeira vista, mas na verdade é
bem simples: o tempo anda da esquerda para a direita neste gráfico, e cada
linha é uma célula de sua array. As linhas curvas que navegam entre linhas
representam um certo valor de um dado. Quando duas linhas se cruzam,
significa que dois valores foram alternados neste momento; uma bifurcação
numa linha representa uma cópia de valor; quando um valor é magenta e
seguido de uma interrogação (?), foi lido usando getValor(); Se o valor é
vermelho e seguido de uma exclamação (!), foi escrito com setValor().</p>

<p>Esta visão, inspirada por Aldo Cortesi, se mostra muito útil para entender o
comportamento interno de algoritmos de ordenação.</p> 

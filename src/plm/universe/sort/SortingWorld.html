<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->
<h1>Sorting World </h1>
This world provides tools to experiment with the sorting algorithms. It can
be used in two different ways: the first one is naturally to write the
required sorting algorithms. But it is also possible to simply use the demo
mode of each exercise to observe the behavior of sorting algorithms. It
helps understanding the differences between each of them.

<h2>Methods available to sorting algorithms</h2>
<table border=1>
<tr><td><b>Method</b></td><td><b>Action</b></td><td><b>Cost</b></td></tr>
<tr><td>[!java|c]int [/!]getValueCount() [!scala]:Int[/!]</td>
    <td>Returns the amount of values in the array</td><td>none</td></tr>

<tr><td>[!java]boolean [/!][!c]int [/!]isSmaller([!java|c]int [/!]i[!scala]:Int[/!], [!java|c]int [/!]j[!scala]:Int[/!]) [!scala]:Boolean[/!]</td>
    <td>Returns true if the content of cell i is strictly smaller than the one of cell j</td><td>two reads</td></tr>
<tr><td>[!java]boolean [/!][!c]int [/!]isSmallerThan([!java|c]int [/!]i[!scala]:Int[/!], [!java|c]int [/!]value[!scala]:Int[/!])[!scala] :Boolean[/!]</td>
    <td>Returns true if the content of cell i is strictly smaller than the <code>value</code></td><td>one read</td></tr>

<tr><td>[!java|c]void [/!]swap([!java|c]int [/!]i[!scala]:Int[/!], [!java|c]int [/!]j[!scala]:Int[/!])</td>
     <td>Swaps the content of cell i and the one of cell j</td><td>two reads, two writes</td></tr>
<tr><td>[!java|c]void [/!]copy([!java|c]int [/!]from[!scala]:Int[/!], [!java|c]int [/!]to[!scala]:Int[/!])</td>
    <td>Copy the content of cell 'from' into the cell 'to'</td><td>one read, one write</td></tr>

<tr><td>[!java|c]int [/!]getValue([!java|c]int [/!]idx[!scala]:Int[/!])</td>
    <td>Returns the value of cell idx</td><td>one read</td></tr>
<tr><td>[!java|c]void [/!]setValue([!java|c]int [/!]idx[!scala]:Int[/!], [!java|c]int [/!]value[!scala]:Int[/!])</td>
    <td>Sets cell 'idx' to the <code>value</code> </td><td>one write</td></tr>

<tr><td>[!java]boolean [/!][!c]int [/!]isSelected() [!scala]:Boolean[/!]</td>
    <td>Returns whether the current world is selected in the graphical interface.</td><td>none</td></tr>

</table>

<h2>History view</h2>
<p>It is not enough to sort the array to pass the exercises. Your solution 
must strictly follow the expected behavior of each exercise. This is
enforced by checking that your algorithm needs the same amount of read
and write operations to sort the array. When they don't match,
understanding the difference between your code and the expected
solution can reveal very difficult.</p>

<p>To help in this process, it is possible to graphically explore the
history of your sorting algorithm. Switch to the Objective view and
use the contextual menu (right click) to switch from the view of
the current state to the view of its history.</p>

<p>The history view is a bit hairly at the first glance, but actually rather
simple: The time flows from left to right on this graph, and each row
is a cell of your array. The curved lines that go navigate between
rows represent a given data value. When two lines cross, this means
that two values were swapped at this time stamp; A line fork represent a 
value copy; When a value is magenta and followed by an interrogation 
mark (?), it was read using getValue(); If the value is red and followed with 
an exclamation point (!), it was written using setValue().</p>

<p>This view, inspired from Aldo Cortesi, reveals very helpful understand the inner
behavior of sorting algorithms.</p> 


<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->
<h1>Mundo da ordenação </h1>
Este mundo fornece ferramentas para experimentar com algoritmos de
ordenação. Pode ser usado de duas formas diferentes: a primeira é
naturalmente para escrever os algoritmos de ordenação necessários. Mas
também é possível simplesmente usar o modo de demonstração de cada exercício
para observar o comportamento de algoritmos de ordenação. Isto ajuda a
entender as diferenças entre cada um deles.

<h2>Métodos disponíveis para algoritmos de ordenação</h2>
<table border=1>
<tr><td><b>Método</b></td><td><b>Ação</b></td><td><b>Custo</b></td></tr>
<tr><td>[!java|c]int [/!]getValueCount() [!scala]:Int[/!]</td>
    <td>Retorna a quantidade de valores na array</td><td>nenhum</td></tr>

<tr><td>[!java]boolean [/!][!c]int [/!]éMenor([!java|c]int [/!]i[!scala]:Int[/!],
[!java|c]int [/!]j[!scala]:Int[/!]) [!scala]:Boolean[/!]</td>
    <td>Retorna true se o conteúdo da célula i é estritamente menor que o da célula
j</td><td>duas leituras</td></tr>
<tr><td>[!java]boolean [/!][!c]int [/!]éMenorQue([!java|c]int [/!]i[!scala]:Int[/!],
[!java|c]int [/!]value[!scala]:Int[/!])[!scala] :Boolean[/!]</td>
    <td>Retorna true se o conteúdo da célula i é estritamente menor que
<code>valor</code></td><td>uma leitura</td></tr>

<tr><td>[!java|c]void [/!]alternar([!java|c]int [/!]i[!scala]:Int[/!], [!java|c]int
[/!]j[!scala]:Int[/!])</td>
     <td>Alterna ("swap") o conteúdo da célula i com o da célula j</td><td>duas escritas, duas leituras</td></tr>
<tr><td>[!java|c]void [/!]copia([!java|c]int [/!]de[!scala]:Int[/!], [!java|c]int
[/!]para[!scala]:Int[/!])</td>
    <td>Copia o conteúdo da célula 'de' para a célula 'para'</td><td>uma leitura, uuma escrita</td></tr>

<tr><td>[!java|c]int [/!]getValor([!java|c]int [/!]idx[!scala]:Int[/!])</td>
    <td>Retorna o valor da célula idx</td><td>uma leitura</td></tr>
<tr><td>[!java|c]void [/!]setValor([!java|c]int [/!]idx[!scala]:Int[/!],
[!java|c]int [/!]valor[!scala]:Int[/!])</td>
    <td>Coloca na célula 'idx' o <code>valor</code> </td><td>uma escrita</td></tr>

<tr><td>[!java]boolean [/!][!c]int [/!]isSelected() [!scala]:Boolean[/!]</td>
    <td>Retorna true se o mundo atual está selecionado na interface gráfica.</td><td>nenhum</td></tr>
</table>

<p>As always, the indices of cells range from 0 to <pre>getValueCount()-1</pre>. Accessing a cell out of this range raises an error. </p>

<h2>Visão do histórico</h2>
<p>É suficiente ordenar a array para resolver os exercícios. A sua solução deve
seguir estritamente o comportamento esperado em cada exercício. Isto é
reforçado a verificar que o seu algoritmo precisa da mesma quantidade de
operações de leitura e escrita para ordenar a array. Quando estas
quantidades não coincidem, compreender a diferença entre o seu código e a
solução esperada pode se mostrar bem difícil.</p>

<p>Para ajudar neste processo, é possível explorar graficamente o histórico do
algoritmo de ordenação. Alternar à visão Objetivo e usar o menu de contexto
(clique com botão direito) para alternar da visão do estado atual à visão do
histórico.</p>

<p>A visão do histórico é um pouco bagunçada à primeira vista, mas na verdade é
bem simples: o tempo anda da esquerda para a direita neste gráfico e cada
linha é uma célula da sua array. As linhas curvas que navegam entre linhas
representam um certo valor de um dado. Quando duas linhas se cruzam,
significa que dois valores foram alternados agora; uma bifurcação numa linha
representa uma cópia de valor; quando um valor é magenta e seguido de uma
interrogação (?), foi lido a usar getValue(); Se o valor é vermelho e
seguido de uma exclamação (!), foi escrito com setValor().</p>

<p>Esta visão, inspirada por Aldo Cortesi, se mostra muito útil para entender o
comportamento interno de algoritmos de ordenação.</p> 

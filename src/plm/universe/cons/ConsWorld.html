<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->
<h1>ConsWorld</h1>

<p>This world allows you to experiment with the recursive lists, as
they were first introduced in Lisp. It is very similar to the BatWorld,
but you are supposed to write recursive functions working on 
[!python|java]recursive strings. Since [!thelang] does not provide
such a construct natively, the ConsWorld defines recursive lists of
type <code>RecList</code>.[/!]
[!scala]lists of integers (<code>List[Int]</code>).[/!]</p>

<p>Any given such list is either the empty list 
(noted <code>[!scala]Nil[/!][!java]null[/!][!python]None[/!]</code>),
or an integer followed by a list. If a list is not empty, you can
retrieve its first integer with <code>list.head</code> and the list
containing its other parameters with <code>list.tail</code>. Of
course, the empty list has no head nor the tail, so trying to access
these elements will result in an (unpleasant) error message.</p>

<p>To build your own list, you need to concatenate a head and a tail
as follows: 
[!java|python]<code>cons(head, tail)</code>[/!]
[!scala]<code>head::tail</code> Note that <code>::</code> is a generic
operator in Scala to build lists.[/!]</p>

<p>So, in summary, you can solve every exercises of this lesson with
the following constructs.</p>

<ul>
<li><b>The empty list:</b> <pre>[!java]null[/!][!scala]Nil[/!][!python]None[/!]</pre></li>
<li><b>Get the first element of <code>l</code></b> <pre>l.head</pre></li>
<li><b>Get the rest of the list</b>, when the first element is removed: <pre>l.tail</pre></li>
<li><b>Build a list</b> from a <code>value</code> and a <code>list</code>: 
[!java|python]<pre>cons(value, list)</pre>[/!]
[!scala]<pre>value::list</pre>[/!]</li>
</ul>
